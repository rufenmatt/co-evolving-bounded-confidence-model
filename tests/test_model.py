import numpy as np
from numpy.random import default_rng, SeedSequence, RandomState, MT19937
import random
from networkx import fast_gnp_random_graph
import networkx as nx
import pytest
import model
import node
from copy import deepcopy
import csv


"""
To run these tests, execute the following command in the command line in the root directory:

python -m pytest
"""


seed=5940583 # fix test seed

@pytest.fixture
def model_params():
    params = {
        "maxsteps" : 10000,
        "tolerance" : 10e-5,
        "alpha" : 0.1,
        "C" : 0.3,
        "tolerance_upper" : 0.35,
        "tolerance_lower" : 0,
        "beta" : 0.25,
        "synthetic" : 'yes',
        "dataset" : 'Reddit',
        "N" : 10,
        "p" : 0.1,
        "M" : 1,
        "K" : 1,
        "trial" : 1
    }
    return params

@pytest.fixture
def seedseq():
    return SeedSequence(seed)

# this function will be used to test whether two nodes are equivalent
def __equivalent_nodes(node1, node2):
    # attrs to check whether two nodes are equivalents
    node_attrs = ['id', 'initial_opinion', 'current_opinion', 'neighbors']
    # this will return True if all of node_attrs of node1 and node2 are equivalent
    return np.all([ getattr(node1,attr) == getattr(node2,attr) for attr in node_attrs] )



"""
Test 1
- Pass in model params as kwargs and test that Model object has all these
"""
def test_model_params(seedseq, model_params):
    modelobj = model.Model(seedseq, **model_params)
    for k,v in model_params.items():
        assert getattr(modelobj,k) == v



"""
Test 2
- Check that all of the initial system attributes have been set
- This should check against values that are manually generated by the same seedseq
- Note: this will also check that initial systems will be producible given the same seedseq
"""
# def test_load_dataset(seedseq, model_params):
#     ssq = deepcopy(seedseq)
#     rng = default_rng(ssq)

#     # Load network and opinion data
#     n_nodes = 10

#     A = np.zeros([n_nodes, n_nodes])
#     X = {i:[] for i in range(n_nodes)}

#     with open("data/test/edges_test.txt", "r") as f:
#         reader = csv.reader(f, delimiter="\t")
#         for u, v in reader:
#             A[int(u)-1, int(v)-1] += 1
#             A[int(v)-1, int(u)-1] += 1

#     with open("data/test/test_opinion.txt","r") as f:
#         reader = csv.reader(f,delimiter="\t")
#         for u,v,w in reader:
#             X[int(u)-1].append(float(w))

#     X = [np.mean(X[i]) for i in range(n_nodes)]
#     X = np.array(X)

#     # Transform adjacency matrix representation into a graph
#     G = nx.from_numpy_array(A)

#     # Generate a uniform distribution of N confidence bounds
#     C_set = rng.uniform(model_params['tolerance_lower'], model_params['tolerance_upper'], n_nodes).tolist()

#     nodes = []
#     for i in range(n_nodes):
#         n_neigh = list(G[i])
#         # assign a confidence bound to a node at random and remove from list
#         C = rng.choice(C_set)
#         C_set.pop(C_set.index(C))
#         n = node.Node(id=i, initial_opinion=X[i], C=C, neighbors=n_neigh)
#         nodes.append(n)

#     # now initialize a Model instance using seedseq and model_params
#     modelobj = model.Model(seedseq, **model_params)

#     # test that we have the same set of edges
#     edges = [(u,v) for u,v in G.edges()]
#     assert edges == modelobj.edges

#     # now test that all nodes are equivalent
#     for i in range(len(nodes)):
#         assert __equivalent_nodes(nodes[i], modelobj.nodes[i])


"""
Test 3
- Check that all of the initial system attributes have been set
- This should check against values that are manually generated by the same seedseq
- Note: this will also check that initial systems will be producible given the same seedseq
"""
def test_init_system(seedseq, model_params):
    # first manually generate a system that we would get if we used the specified seed
    ssq = deepcopy(seedseq)
    rng = default_rng(ssq)
    rs = RandomState(MT19937(ssq))
    X = rng.random(model_params['N'])
    G = fast_gnp_random_graph(n=model_params['N'], p=model_params['p'], seed=rs, directed=False)

    # Generate a uniform distribution of N confidence bounds
    C_set = rng.uniform(model_params['tolerance_lower'], model_params['tolerance_upper'], model_params['N']).tolist()

    nodes = []
    for i in range(model_params['N']):
        n_neigh = list(G[i])
        # assign a confidence bound to a node at random and remove from list
        C = rng.choice(C_set)
        C_set.pop(C_set.index(C))
        n = node.Node(id=i, initial_opinion=X[i], C=C, neighbors=n_neigh)
        nodes.append(n)

    # now initialize a Model instance using seedseq and model_params
    modelobj = model.Model(seedseq, **model_params)

    # test that we have the same set of edges
    edges = [(u,v) for u,v in G.edges()]
    assert edges == modelobj.edges

    # now test that all nodes are equivalent
    for i in range(len(nodes)):
        assert __equivalent_nodes(nodes[i], modelobj.nodes[i])



"""
Test 4
- Test that if I pickle a model object and load it, I can access its Node objects and other data
"""
def test_compressed_pickle(seedseq, model_params):
    import pickle
    import _pickle as cPickle
    import bz2

    ssq = deepcopy(seedseq)
    rng = default_rng(ssq)
    rs = RandomState(MT19937(ssq))

    n_nodes = model_params['N']

    # synthetic networks
    X = rng.random(model_params['N'])
    G = fast_gnp_random_graph(n=model_params['N'], p=model_params['p'], seed=rs, directed=False)


    # # real-world networks
    # A = np.zeros([n_nodes, n_nodes])
    # X = {i:[] for i in range(n_nodes)}

    # with open("data/test/edges_test.txt", "r") as f:
    #     reader = csv.reader(f, delimiter="\t")
    #     for u, v in reader:
    #         A[int(u)-1, int(v)-1] += 1
    #         A[int(v)-1, int(u)-1] += 1

    # with open("data/test/test_opinion.txt","r") as f:
    #     reader = csv.reader(f,delimiter="\t")
    #     for u,v,w in reader:
    #         X[int(u)-1].append(float(w))

    # X = [np.mean(X[i]) for i in range(n_nodes)]
    # X = np.array(X)

    # # Transform adjacency matrix representation into a graph
    # G = nx.from_numpy_array(A)

    # Generate a uniform distribution of N confidence bounds

    C_set = rng.uniform(model_params['tolerance_lower'], model_params['tolerance_upper'], n_nodes).tolist()

    nodes = []
    for i in range(n_nodes):
        n_neigh = list(G[i])
        # assign a confidence bound to a node at random and remove from list
        C = rng.choice(C_set)
        C_set.pop(C_set.index(C))
        n = node.Node(id=i, initial_opinion=X[i], C=C, neighbors=n_neigh)
        nodes.append(n)

    # now initialize a Model instance using seedseq and model_params
    modelobj = model.Model(seedseq, **model_params)
    # pickle the Model object
    with bz2.BZ2File('test_compressed_pickle.pbz2', 'w') as f:
        cPickle.dump(modelobj, f)
    # load the pickled model
    loaded_model = bz2.BZ2File('test_compressed_pickle.pbz2', 'rb')
    loaded_model = cPickle.load(loaded_model)

    # test that we have the same set of edges
    edges = [(u,v) for u,v in G.edges()]
    assert edges == loaded_model.edges

    # now test that all nodes are equivalent
    for i in range(len(nodes)):
        assert __equivalent_nodes(nodes[i], loaded_model.nodes[i])



"""
Test 5
Test that rewire_step() works properly.
For this test, the only function that Model.run() invokes is it inner rewire_step() function.
For example,

def run(self):
    def rewire_step():
        ...

    while ((t <= self.maxsteps-1) & (self.stationary_marker != 1)):
        rewire_step()
        t+=1
"""
def test_rewire(seedseq, model_params):
    modelobj = model.Model(seedseq, **model_params)
    orig_edges = modelobj.edges.copy()
    print(orig_edges)
    print([(i,j) for (i,j) in modelobj.edges if abs(modelobj.X[i] - modelobj.X[j]) >= modelobj.beta])
    num_discordant_start = len([(i,j) for (i,j) in modelobj.edges if abs(modelobj.X[i] - modelobj.X[j]) >= modelobj.beta])
    modelobj.run()
    num_discordant_end = len([(i,j) for (i,j) in modelobj.edges if abs(modelobj.X[i] - modelobj.X[j]) >= modelobj.beta])
    print(modelobj.edges)
    print(modelobj.edge_changes)
    assert modelobj.edges != orig_edges
    assert num_discordant_start > num_discordant_end



"""
Test 6
Test that dw_step() and check_convergence() works properly.
"""
def test_dw(seedseq, model_params):
    modelobj = model.Model(seedseq, **model_params)
    modelobj.run()
    assert modelobj.stationary_marker == 1
    ct=modelobj.convergence_time

    assert np.sum(np.abs(modelobj.X_data[ct-50,:] - modelobj.X_data[ct-51,:])) < modelobj.tolerance
    assert np.sum(np.abs(modelobj.X_data[ct-2,:] - modelobj.X_data[ct-1,:])) < modelobj.tolerance



"""
Test 7
- Test get_network() works properly.
- Test cases:
    - get_network(t=0) is the same graph as the initial network
    - get_network(t=1) is the same graph after first step of rewiring
    - get_network(t=2) is the same graph after 2 steps of rewiring
"""
# we need one test_get_network for synthetic and one for real-world networks
def test_get_network(seedseq, model_params):
    #import networkx as nx

    modelobj = model.Model(seedseq, **model_params)
    modelobj.run()
    assert list(modelobj.get_network(t=0).edges) == modelobj.initial_edges

    # synthetic networks
    # starting edges: [(3, 6), (5, 6), (7, 8)]
    # first edge change recorded: (0, (7, 8), (8, 5))
    # so, edge set after the first step is [(3, 6), (5, 6), (7, 8)]
    assert list(modelobj.get_network(t=1).edges) == [(3, 6), (5, 6), (5, 8)]

    # starting edges at t=1: [(3, 6), (5, 6), (5, 8)]
    # second edge change recorded: (1, (8, 5), (5, 9))
    # so, edge set after the second step is [(3, 6), (5, 6), (5, 9)]
    assert list(modelobj.get_network(t=2).edges) == [(3, 6), (5, 6), (5, 9)]

    # # real-world networks
    # # starting edges: [(0, 4), (1, 5), (1, 7), (2, 3), (3, 4), (4, 8)]
    # # first edge change recorded: (0, (1, 5), (1, 2))
    # # so, edge set after the first step is [(0, 4), (1, 7), (1, 3), (2, 3), (3, 4), (4, 8)]
    # assert list(modelobj.get_network(t=1).edges) == [(0, 4), (1, 7), (1, 2), (2, 3), (3, 4), (4, 8)]

    # # starting edges at t=1: [(0, 4), (1, 5), (1, 7), (2, 3), (3, 4), (4, 8)]
    # # second edge change recorded: (1, (0, 4), (0, 8))
    # # so, edge set after the second step is [(0, 8), (1, 5), (1, 3), (2, 3), (3, 4), (4, 8)]
    # assert list(modelobj.get_network(t=2).edges) == [(0, 8), (1, 7), (1, 2), (2, 3), (3, 4), (4, 8)]



"""
Test 8
- Check that save_model() works properly.
"""
def test_save_model(seedseq, model_params):
    import pickle
    import _pickle as cPickle
    import bz2

    modelobj = model.Model(seedseq, **model_params)
    modelobj.run()
    modelobj.save_model()

    loaded_model = bz2.BZ2File('data/C_030_beta_025_trial_1_spk_None.pbz2', 'rb')
    loaded_model = cPickle.load(loaded_model)

    X_data = modelobj.X_data.copy()
    X_data[~np.all(X_data == 0, axis=1)]
    assert (X_data == loaded_model.X_data).all()
    assert modelobj.edges == loaded_model.edges
    for i in range(len(modelobj.nodes)):
        assert __equivalent_nodes(modelobj.nodes[i], loaded_model.nodes[i])
